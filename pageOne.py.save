from kivy.uix.dropdown import DropDown
from kivy.uix.textinput import TextInput
from kivy.uix.gridlayout import GridLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.scrollview import ScrollView
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.clock import Clock
import lgpio
import time


class PageOne(Screen):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.main_layout = BoxLayout(orientation='vertical', padding=10)
        self.create_main_content()
        self.add_widget(self.main_layout)

    def create_main_content(self):
        self.main_layout.clear_widgets()
        robot_label = Label(text="Robot Page", font_size=32, color=(1, 1, 1, 1))
        form_button = Button(text="Open Form", size_hint=(None, None), size=(200, 50))
        form_button.bind(on_release=self.show_form)
        start_button = Button(text="Start Robot", size_hint=(None, None), size=(200, 50))
        start_button.bind(on_release=self.start_initial_countdown)
        self.main_layout.add_widget(robot_label)
        self.main_layout.add_widget(form_button)
        self.main_layout.add_widget(start_button)

    def show_form(self, instance):
        self.main_layout.clear_widgets()

        # Title for the form with updated styling
        form_title = Label(
            text="User Form", 
            font_size=35, 
            color=(1, 0.84, 0, 1),  # Gold color
            bold=True, 
        )
        self.main_layout.add_widget(form_title)

        # Adjusted GridLayout for wider columns
        form_layout = GridLayout(cols=4, padding=1, spacing=1, size_hint_y=None)
        form_layout.bind(minimum_height=form_layout.setter('height'))

        # Create headers
        headers = ['EMPLOYEE NAME','WARD NAME', 'ROOM NUMBER', 'BED NUMBER']
        for header in headers:
            header_label = Label(text=header, font_size=14, bold=True, color=(1, 1, 1, 1), size_hint=(None, None), width=150, height=40)
            form_layout.add_widget(header_label)

        # Populate the table with data input fields with increased column width
        for row in range(19):  # Adjust the range as needed for more rows
            employee_name_input = TextInput(text='', font_size=12, multiline=False, size_hint=(None, None), width=150,height=40)
            ward_name_input = TextInput(text='', font_size=12, multiline=False, size_hint=(None, None), width=150,height=40)
            room_number_input = TextInput(text='', font_size=12, multiline=False, size_hint=(None, None), width=150,height=40)
            bed_number_input = TextInput(text='', font_size=12, multiline=False, size_hint=(None, None), width=150,height=40)
            form_layout.add_widget(ward_name_input)
            form_layout.add_widget(employee_name_input)
            form_layout.add_widget(room_number_input)
            form_layout.add_widget(bed_number_input)

        # Create ScrollView to make the table scrollable
        scroll_view = ScrollView(size_hint=(1, None), size=(self.width, 400))
        scroll_view.add_widget(form_layout)
        self.main_layout.add_widget(scroll_view)

        # Add back button
        back_button = Button(text="Back", size_hint=(None, None), size=(100, 50))
        back_button.bind(on_release=self.show_main_content)
        self.main_layout.add_widget(back_button)

    def show_main_content(self, instance):
        self.create_main_content()

    def submit_form(self, instance):
        print("Form submitted!")

    def start_initial_countdown(self, instance):
        self.main_layout.clear_widgets()
        self.countdown_label = Label(
            text="You have \n 60 seconds \nto leave the room",
            font_size=65,
            color=(1, 0.84, 0, 1),
            bold=True
        )
        self.main_layout.add_widget(self.countdown_label)
        self.countdown_time = 10  # 60 seconds
        Clock.schedule_interval(self.update_initial_countdown, 1)

    def update_initial_countdown(self, dt):
        if self.countdown_time > 0:
            self.countdown_label.text = f"You have \n {self.countdown_time} seconds \n to leave the room"
            self.countdown_time -= 1
        else:
            Clock.unschedule(self.update_initial_countdown)
            self.start_ten_minute_countdown()

    def start_ten_minute_countdown(self):
        self.main_layout.clear_widgets()
        self.countdown_label = Label(
            text="10:00",
            font_size=200,
            color=(1, 0.84, 0, 1),
            bold=True
        )
        self.main_layout.add_widget(self.countdown_label)
        self.countdown_time = 10  # 10 minutes in seconds
        Clock.schedule_interval(self.update_ten_minute_countdown, 1)
        
        led1 = 15
        import RPi.GPIO as GPIO
        import time

        GPIO.setmode(GPIO.BCM)
   while True:
            GPIO.output(led1, True)
            time.sleep(2)
            GPIO.output(led1, False)
        time.sleep(2)

    def update_ten_minute_countdown(self, dt):
        if self.countdown_time > 0:
            minutes, seconds = divmod(self.countdown_time, 60)
            self.countdown_label.text = f"{minutes:02}:{seconds:02}"
            self.countdown_time -= 1
        else:
            self.countdown_label.text = "Countdown Complete!"
            Clock.unschedule(self.update_ten_minute_countdown)
            self.show_cleaning_complete_message()

    def show_cleaning_complete_message(self):
        self.main_layout.clear_widgets()
        cleaning_complete_label = Label(
            text="Cleaning complete",
            font_size=34,
            color=(1, 0.84, 0, 1),
            bold=True
        )
        self.main_layout.add_widget(cleaning_complete_label)

        # Display the questions after cleaning
        self.display_after_cleaning_questions()

    def display_after_cleaning_questions(self):
        # Questions to be asked after the cleaning is complete
        after_cleaning_questions = [
            ("Did the robot complete its cleaning cycle without any interruptions (errors, alarms)?", ["Yes", "No (Please describe the interruption)"]),
            ("Did you visually inspect the bed surface after the robot's cleaning cycle?", ["Yes", "No"]),
            ("If you answered yes to question 2, did you notice any areas that appeared to be inadequately disinfected?", ["Yes (Please describe the areas)", "No"]),
        ]

        # Dynamically create form fields based on after-cleaning questions
        for question_text, options in after_cleaning_questions:
            question_label = Label(text=question_text, font_size=18)
            question_dropdown = DropDown()
            question_button = Button(text='Select', size_hint_y=None, height=44, font_size=12)
            question_button.bind(on_release=question_dropdown.open)
            question_dropdown.bind(on_select=lambda instance, x: setattr(question_button, 'text', x))
            
            for option in options:
                btn = Button(text=option, size_hint_y=None, height=44)
                btn.bind(on_release=lambda btn: question_dropdown.select(btn.text))
                question_dropdown.add_widget(btn)
                
            self.main_layout.add_widget(question_label)
            self.main_layout.add_widget(question_button)

        # Add the additional comments or suggestions question with a TextInput field
        comments_label = Label(text="Please share any additional comments or suggestions regarding the use of the light disinfectant robot:", font_size=12)
        comments_input = TextInput(hint_text="Your comments here...", multiline=True, size_hint_y=None, height=100, font_size=12)
        
        self.main_layout.add_widget(comments_label)
        self.main_layout.add_widget(comments_input)

        # Submit button at the end of the questions
        submit_button = Button(text="Submit", size_hint=(None, None), size=(100, 50))
        submit_button.bind(on_release=self.submit_form)
        self.main_layout.add_widget(submit_button)

    def submit_form(self, instance):
        print("Form submitted!")

        back_button = Button(text="Back", size_hint=(None, None), size=(100, 50))
        back_button.bind(on_release=self.show_main_content)
        self.main_layout.add_widget(back_button)
